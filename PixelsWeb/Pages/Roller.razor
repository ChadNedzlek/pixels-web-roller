@page "/roller"
@using Rolling
@using Blazored.LocalStorage
@using System.Collections.Immutable
@using Rolling.Models.Definitions
@using Rolling.Parsing
@using Rolling.Utilities
@inject ILocalStorageService LocalStorage

<PageTitle>Roller</PageTitle>

<div class="container">
    <div class="accordion" id="definition-accordion">
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-definition" aria-expanded="true" aria-controls="collapse-definition">
                    Definition
                </button>
            </h2>
            <div id="collapse-definition" class="accordion-collapse collapse @(_sheet.IsNone ? "show" : "")" data-bs-parent="#definition-accordion">
                <div class="accordion-body">
                    <div class="row">
                        <label for="roll-definitions" class="form-label">
                            Roll Definition
                            <a data-bs-toggle="offcanvas" href="#syntax-help" role="link" aria-controls="syntax-help"><span class="badge bg-primary rounded-pill">?</span></a>
                        </label>
                        <textarea class="form-control @(_errorMessage != null ? "is-invalid" : "")" rows="5" id="roll-definitions" @bind:after="RollChanged" @bind="_rollText" placeholder="3d6 + 7"></textarea>
                        <div class="form-text text-danger">@_errorMessage</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="offcanvas offcanvas-start" tabindex="-1" id="syntax-help" aria-labelledby="syntax-title">
        <div class="offcanvas-header">
            <h4 class="offcanvas-title" id="sytanx-title">Syntax Help</h4>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <h5>Basic rolls</h5>
            <p>Rolls can be written in straightforward manner.</p>
            <ul>
                <li><code>2d12</code></li>
                <li><code>3d6 + 2d4 + 5</code></li>
            </ul>
            <p>The count of dice can be skipped for single dice.</p>
            <ul>
                <li><code>d20 + 12</code></li>
            </ul>
            <h5>Named rolls</h5>
            <p>Any roll can be named, by surrounding the name with colons before a roll, with :NAME:</p>
            <ul>
                <li><code>:Perception: d20 + 12</code></li>
            </ul>
            <h5>Multiple rolls</h5>
            <p>Multiple rolls can be specified, most easily by separating them with line breaks</p>
            <p class="text-muted">Technically newlines are optional, but it's much easier to read</p>
            <ul>
                <li><pre><code>d20 + 10
3d6 + 7</code></pre></li>
                <li><pre><code>:Attack: d20 + 10
:Fireball: 3d6 + 7</code></pre></li>
            </ul>
            <h5>Roll tags</h5>
            <p>Dices and modifiers can be tagged, with, for example, damage types. Tagged dice will be kept seprate when rolled and not summed into the total. To tag a roll, just follow it with some words.</p>
            <ul>
                <li><code>2d6 + 10 + 1d6 fire</code></li>
                <li><code>d20 + 4 against poison</code></li>
            </ul>
            <h5>Conditional rolls</h5>
            <p>Conditional rolls (for example, an attack roll followed by the damage if it hits), are separated by <code>=></code></p>
            <ul>
                <li><code>d20 + 15 => 3d6 + 7 + 1d6 fire</code></li>
            </ul>
            <h5>Roll groups</h5>
            <p>Rolls can be grouped, both for visual collapsing of groups, as well as for easy rolling with external devices by providing a title surrounded by  <code>===</code> or <code>***</code></p>
            <p>Groups with <code>===</code> (the default) will use a single die roll (or set of dice) for all dice in that group, do if you have 3 rolls that all use a "d20", the same d20 will be used in every roll</p>
            <p>Groups with <code>***</code> will use different values/dice for every roll in the group</p>
            <ul>
                <li><pre><code>=== Skills ===
:Perception: d20 + 7
:Stealth: d20 + 11 + 3 in shadows
:Fireball: 3d6 + 7</code></pre></li>
                <li><pre><code>*** Attacks ***
:Attack 1: d20 + 10 => 3d6 + 5
:Attack 2: d20 + 5 => 3d6 + 5</code></pre></li>
            </ul>
        </div>
    </div>

    @if (_sheet.TryValue(out SheetDefinition sheet))
    {
        <div class="row">

            <div class="btn-group" role="group" aria-label="Basic checkbox toggle button group">
                @* <button type="button" class="btn btn-primary col-8-sm" @onclick="RollAll">roll all</button> *@

                <input type="checkbox" class="btn-check" id="show-details" autocomplete="off" @bind="_showDetails">
                <label class="btn btn-outline-primary  col-8-sm" for="show-details">show details</label>
            </div>
        </div>

        int sectionId = 0;
        <div class="accordion" id="roll-accordion">
            @foreach (SheetDefinitionSection sect in sheet.Sections)
            {
                sectionId++;
                int id = 1;
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-@sectionId" aria-expanded="true" aria-controls="collapse-@sectionId">
                            @sect.Name.Or($"Section {sectionId}")
                        </button>
                    </h2>
                    <div id="collapse-@sectionId" class="accordion-collapse collapse show">
                        <div class="accordion-body">
                            <div class="row row-cols-1 row-cols-sm-2 row-cols-lg-3 row-cols-xl-4">
                                @foreach (DiceRollDefinition roll in sect.Rolls)
                                {
                                    id++;
                                    <div class="col">
                                        <div class="card">
                                            <div class="card-header">@roll.Name.Or($"Roll {id}")</div>
                                            <div class="card-body">
                                                <h6 class="card-subtitle mb-2 text-body-secondary">@roll.Expression.ToString()</h6>
                                                @* @if (roll.Roll.Result.TryValue(out var res)) *@
                                                @* { *@
                                                @*     <h5 class="card-title"> *@
                                                @*         @if (res.ConditionalRolls.TryValue(out var cRoll)) *@
                                                @*         { *@
                                                @*             foreach (var part in cRoll) *@
                                                @*             { *@
                                                @*                 <span class="badge text-bg-dark mx-1">@DieText(part)</span> *@
                                                @*             } *@
                                                @*             <span class="bi bi-chevron-double-right" alt="result"></span> *@
                                                @*         } *@
                                                @*         @foreach (var part in res.ValueRolls) *@
                                                @*         { *@
                                                @*             <span class="badge text-bg-dark mx-1">@DieText(part)</span> *@
                                                @*         } *@
                                                @*     </h5> *@
                                                @* *@
                                                @*     <div class="accordion" id="roll--accordion"></div> *@
                                                @* } *@
                                            </div>
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            }
        </div>
    }
</div>

@code {
    private readonly RollParser _parser = new();
    private bool _showDetails = false;

    private string DieText(SingleRollResult gr)
    {
        string valueText;
        if (_showDetails)
        {
            IOrderedEnumerable<IGrouping<int,RawRoll>> sortedGroups = gr.Rolls.GroupBy(r => r.Size).OrderByDescending(g => g.Key);
            IEnumerable<string> groupText = sortedGroups.Select(g => g.Key == 1 ? g.Count().ToString() : string.Join(",", g.Select(d => d.Result)));
            valueText = string.Join(" + ", groupText);
        }
        else
            valueText = gr.Total.ToString();
        return gr.Tag.Match(t => $"{valueText} {t}", valueText);
    }

    // private void RollAll()
    // {
    //     if (!_sheet.TryValue(out var sheet))
    //         return;
    //     foreach (var section in sheet.Sections)
    //     {
    //         var dice = section.GetRequiredDiceCounts();
    //         var rollBuilder = ImmutableList.CreateBuilder<DieRoll>();
    //         foreach ((int size, int count) in dice)
    //         {
    //             for (int i = 0; i < count; i++)
    //             {
    //                 rollBuilder.Add(DieRoll.Random(size));
    //             }
    //         }
    //         var rolls = rollBuilder.ToImmutableList();
    //         RollPool pool = null;
    //         foreach (var roll in section.Rolls)
    //         {
    //             if (pool == null || section.Type == RollSectionType.RepeatDice)
    //             {
    //                 pool = new RollPool(rolls);
    //             }
    //
    //             roll.Roll.Roll(pool);
    //         }
    //     }
    // }

    private Task RollChanged()
    {
        return ParseAndSaveRolls(_rollText);
    }

    private async Task ParseAndSaveRolls(string value)
    {
        if (value == null) return;
        Either<SheetDefinition, string> res = _parser.TryParse(value);
        await res.Match(
            async result =>
            {
                _errorMessage = null;
                _sheet = result;
                await LocalStorage.SetItemAsync("roll-text", value);
            },
            errorMessage =>
            {
                _errorMessage = errorMessage;
                return Task.CompletedTask;
            }
            );
    }

    private string _rollText;
    private string _errorMessage;
    private Maybe<SheetDefinition> _sheet;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        _rollText = await LocalStorage.GetItemAsync<string>("roll-text");
        if (_rollText != null) await ParseAndSaveRolls(_rollText);
    }

}