@page "/roller"
@using Blazored.LocalStorage
@using PixelsBlazorInterop
@using Rolling.Models.Rolls
@using Rolling.Utilities
@using Rolling.Visitors
@inject ILocalStorageService LocalStorage
@inject PixelsManager PixelsManager
@inject IJSRuntime JsRuntime

<PageTitle>Roller</PageTitle>

<div class="container">
    <div class="toast-container position-fixed bottom-0 end-0 p-3">
      <div id="failed-to-connect-toast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header">
          <span class="bi bi-exclamation-circle-fill rounded me-2 text-danger" aria-hidden="true"></span>
          <strong class="me-auto">Error</strong>
          <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body">
          failed to connect to pixels dice.
        </div>
      </div>
    </div>
    <div class="accordion" id="connected-accordion">
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-connected" aria-expanded="true" aria-controls="collapse-connected">
                    connected dice
                </button>
            </h2>
            <div id="collapse-connected" class="accordion-collapse collapse show" data-bs-parent="#connected-accordion">
                <div class="accordion-body">
                    <div class="row">
                        @foreach (var die in _connectedDice)
                        {
                            <div class="card" style="width: 8rem">
                                <div class="card-body">
                                    <h5 class="card-subtitle">@die.Name</h5>
                                    <p class="card-text">
                                        @if (die.RollState == "onFace")
                                        {
                                            <span class="badge text-bg-primary">@die.Face</span>
                                        }
                                        else
                                        {
                                            @die.RollState
                                        }
                                    </p>
                                </div>
                            </div>
                        }
                    </div>
                        <div class="row">
                            <div class="btn-group" role="group" aria-label="Basic checkbox toggle button group">
                                <button type="button" class="btn btn-primary col-8-sm" @onclick="ConnectPixels">connect dice</button>
                            </div>
                        </div>
                    </div>
            </div>
    </div>
    </div>
    <div class="accordion" id="definition-accordion">
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-definition" aria-expanded="true" aria-controls="collapse-definition">
                    roll definitions
                </button>
            </h2>
            <div id="collapse-definition" class="accordion-collapse collapse @(_sheet.IsNone ? "show" : "")" data-bs-parent="#definition-accordion">
                <div class="accordion-body">
                    <div class="row">
                        <label for="roll-definitions" class="form-label">
                            roll text
                            <a data-bs-toggle="offcanvas" href="#syntax-help" role="link" aria-controls="syntax-help"><span class="badge bg-primary rounded-pill">?</span></a>
                        </label>
                        <textarea class="form-control @(_errorMessage != null ? "is-invalid" : "")" rows="5" id="roll-definitions" @bind:after="RollChanged" @bind="_rollText" placeholder="3d6 + 7"></textarea>
                        <div class="form-text text-danger">@_errorMessage</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="offcanvas offcanvas-start" tabindex="-1" id="syntax-help" aria-labelledby="syntax-title">
        <div class="offcanvas-header">
            <h4 class="offcanvas-title" id="sytanx-title">Syntax Help</h4>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <h5>Basic rolls</h5>
            <p>Rolls can be written in straightforward manner.</p>
            <ul>
                <li><code>2d12</code></li>
                <li><code>3d6 + 2d4 + 5</code></li>
            </ul>
            <p>The count of dice can be skipped for single dice.</p>
            <ul>
                <li><code>d20 + 12</code></li>
            </ul>
            <h5>Named rolls</h5>
            <p>Any roll can be named, by putting it before a colon in front of a roll</p>
            <ul>
                <li><code>Perception: d20 + 12</code></li>
            </ul>
            <h5>Multiple rolls</h5>
            <p>Multiple rolls can be specified, each on it's own line</p>
            <ul>
                <li><pre><code>d20 + 10
3d6 + 7</code></pre></li>
                <li><pre><code>Attack: d20 + 10
Fireball: 3d6 + 7</code></pre></li>
            </ul>
            <h5>Roll tags</h5>
            <p>Dices and modifiers can be tagged, with, for example, damage types. Tagged dice will be kept seprate when rolled and not summed into the total. To tag a roll, just follow it with some words.</p>
            <ul>
                <li><code>2d6 + 10 + 1d6 fire</code></li>
                <li><code>d20 + 4 against poison</code></li>
            </ul>
            <h5>Conditional rolls</h5>
            <p>Conditional rolls (for example, an attack roll followed by the damage if it hits), are separated by <code>=></code></p>
            <ul>
                <li><code>d20 + 15 => 3d6 + 7 + 1d6 fire</code></li>
            </ul>
            <h5>Roll groups</h5>
            <p>Rolls can be grouped, both for visual collapsing of groups, as well as for easy rolling with external devices by providing a title surrounded by  <code>===</code> or <code>***</code></p>
            <p>Groups with <code>===</code> (the default) will use a single die roll (or set of dice) for all dice in that group, do if you have 3 rolls that all use a "d20", the same d20 will be used in every roll</p>
            <p>Groups with <code>***</code> will use different values/dice for every roll in the group</p>
            <ul>
                <li><pre><code>=== Skills ===
Perception: d20 + 7
Stealth: d20 + 11 + 3 in shadows
Fireball: 3d6 + 7</code></pre></li>
                <li><pre><code>*** Attacks ***
Attack 1: d20 + 10 => 3d6 + 5
Attack 2: d20 + 5 => 3d6 + 5</code></pre></li>
            </ul>
        </div>
    </div>

    @if (_sheet.TryValue(out EvaluatedSheet<Maybe<RollExpressionResult>> sheet))
    {
        <div class="row">

            <div class="btn-group" role="group" aria-label="Basic checkbox toggle button group">
                <button type="button" class="btn btn-primary col-8-sm" @onclick="RollAll">roll all</button>

                <input type="checkbox" class="btn-check" id="show-details" autocomplete="off" @bind="_showDetails">
                <label class="btn btn-outline-primary  col-8-sm" for="show-details">show details</label>
            </div>
        </div>

        int sectionId = 0;
        <div class="accordion" id="roll-accordion">
            @foreach (EvaluatedSection<Maybe<RollExpressionResult>> sect in sheet.Sections)
            {
                sectionId++;
                int id = 1;
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-@sectionId" aria-expanded="true" aria-controls="collapse-@sectionId">
                            @sect.Name.Or($"Section {sectionId}")
                        </button>
                    </h2>
                    <div id="collapse-@sectionId" class="accordion-collapse collapse show">
                        <div class="accordion-body">
                            <div class="row row-cols-1 row-cols-sm-2 row-cols-lg-3 row-cols-xl-4">
                                @foreach (EvaluatedRoll<Maybe<RollExpressionResult>> roll in sect.Rolls)
                                {
                                    id++;
                                    <div class="col">
                                        <div class="card">
                                            <div class="card-header">@roll.Definition.Name.Or($"Roll {id}")</div>
                                            <div class="card-body">
                                                <h6 class="card-subtitle mb-2 text-body-secondary">
                                                    @_describer.Evaluate(roll.Definition.Expression)
                                                    @roll.Definition.ConditionalExpression.Match(e => " => " + _describer.Evaluate(e), "")
                                                </h6>
                                                @if (roll.Value.TryValue(out var res))
                                                {
                                                    @DieText(res);
                                                    if (roll.ConditionalValue.OrDefault().TryValue(out var cond))
                                                    {
                                                        <span> => </span>
                                                        @DieText(cond);
                                                    }
                                                }
                                            </div>
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            }
        </div>
    }
</div>

@code {

    private RenderFragment DieText(RollExpressionResult gr)
    {
        return @<span>@GroupText(gr.Groups[0])
           @foreach (var (g, o) in gr.Groups.Skip(1).Zip(gr.Operations))
           {
               <span> @o </span>
               @GroupText(g)
           }
       </span>;
    }

    private RenderFragment CritFail() => @<span class="visually-hidden">(crit. fail)</span>;
    private RenderFragment CritSuccess() => @<span class="visually-hidden">(crit. fail)</span>;

    private RenderFragment RenderDieRoll(SingleRollResult singleRollResult)
    {

        string CalcColor(AssignedDieRoll d)
        {
            if (d.Dropped)
                return "text-bg-secondary";
            if (singleRollResult.CriticalFailure)
                return "text-bg-danger";
            if (singleRollResult.CriticalSuccess)
                return "text-bg-success";
            if (d.Value.Id.IsNone)
                return "text-bg-dark";
            return "text-bg-primary";
        }

        return @<span>
            @foreach (var roll in singleRollResult.Rolls)
            {
            <span class="badge @CalcColor(roll)">
                @roll.Value.Result
                @if (roll.Dropped)
                {
                    <span class="visually-hidden">(dropped)</span>
                }
            </span>
            }
            </span>;
    }

    private RenderFragment RenderConstant(RollResult rollResult) => @<span class="badge text-bg-dark">@rollResult.Value </span>;

    private RenderFragment RenderSingleGroupItem(RollResult item)
    {
        RenderFragment renderedDie = item switch {
            SingleRollResult res => RenderDieRoll(res),
            var i =>RenderConstant(i),
            };
        return renderedDie;
    }

    private RenderFragment GroupText(RollResultGroup group)
    {
        RenderFragment hidden = null;
        var dice = group.Items.OfType<SingleRollResult>().ToList();
        if (dice.Any(d => d.CriticalFailure))
        {
            hidden = CritFail();
        }
        if (dice.Any(d => d.CriticalSuccess))
        {
            hidden = CritSuccess();
        }
        
        if (_showDetails)
        {
            return @<span>
                @RenderSingleGroupItem(group.Items[0])
                @foreach (var (item, op) in group.Items.Skip(1).Zip(group.Operations))
                {
                   <span>@op</span>
                   
                   @RenderSingleGroupItem(item)
                }
                @hidden @group.Tag.OrDefault()
           </span>;
        }

        string color = "text-bg-dark";
        if (dice.Any(d => d.Rolls.Any(r => !r.Value.Id.IsNone)))
        {
            color = "text-bg-primary";
        }
        if (dice.Any(d => d.CriticalFailure))
        {
            color = "text-bg-danger";
        }
        if (dice.Any(d => d.CriticalSuccess))
        {
            color = "text-bg-success";
        }

        return @<span class="badge @color">@group.Value @hidden @group.Tag.OrDefault()</span>;
    }

}